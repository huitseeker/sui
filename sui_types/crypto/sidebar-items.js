initSidebarItems({"constant":[["SUI_SIGNATURE_LENGTH",""]],"fn":[["get_key_pair",""],["get_key_pair_from_bytes",""],["get_key_pair_from_rng","Generate a keypair from the specified RNG (useful for testing with seedable rngs)."],["random_key_pairs",""],["sha3_hash",""]],"struct":[["AuthorityQuorumSignInfo","Represents at least a quorum (could be more) of authority signatures."],["AuthoritySignInfo",""],["AuthoritySignature","A signature emitted by an authority. Itâ€™s useful to decouple this from user signatures, as their set of supported schemes will probably diverge"],["EmptySignInfo",""],["KeyPair",""],["PublicKeyBytes",""],["Signature",""],["VerificationObligation",""]],"trait":[["AuthoritySignInfoTrait","AuthoritySignInfoTrait is a trait used specifically for a few structs in messages.rs to template on whether the struct is signed by an authority. We want to limit how those structs can be instanted on, hence the sealed trait. TODO: We could also add the aggregated signature as another impl of the trait. This will make CertifiedTransaction also an instance of the same struct."],["BcsSignable","Activate the blanket implementation of `Signable` based on serde and BCS."],["Signable","Something that we know how to hash and sign."],["SignableBytes",""]],"type":[["PubKeyLookup",""]]});